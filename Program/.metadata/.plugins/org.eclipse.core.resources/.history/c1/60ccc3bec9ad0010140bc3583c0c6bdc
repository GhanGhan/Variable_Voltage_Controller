/*
 * NHD_lcd.c
 *
 *  Created on: Aug 21, 2025
 *      Author: Ghani
 */

#include "main.h"
#include "fonts.h"
#include "NHD_lcd.h"
#include "NHD_lcd_config.h"
#include <string.h>

static uint8_t last_len[NUM_CHAR_ROWS] = {0};


// Pin Control Helper Functions
static void LCD_Select(NHD_LCD_Handle_t* lcd_handle)
{
  HAL_GPIO_WritePin(lcd_handle->cs_port, lcd_handle->cs_pin, GPIO_PIN_RESET);  //Select LCD Screen
}

static void LCD_DeSelect(NHD_LCD_Handle_t* lcd_handle)
{
  HAL_GPIO_WritePin(lcd_handle->cs_port, lcd_handle->cs_pin, GPIO_PIN_SET);  //De-Select LCD Screen
}

static void LCD_OP_Command(NHD_LCD_Handle_t* lcd_handle)
{
  HAL_GPIO_WritePin(lcd_handle->op_port, lcd_handle->op_pin, GPIO_PIN_RESET);  //Set message type to command
}

static void LCD_OP_Data(NHD_LCD_Handle_t* lcd_handle)
{
  HAL_GPIO_WritePin(lcd_handle->op_port, lcd_handle->op_pin, GPIO_PIN_SET);
}

static void LCD_Reset_LOW(NHD_LCD_Handle_t * lcd_handle)
{
  HAL_GPIO_WritePin(lcd_handle->reset_port, lcd_handle->reset_pin, GPIO_PIN_RESET);
}

static void LCD_Reset_HIGH(NHD_LCD_Handle_t* lcd_handle)
{
  HAL_GPIO_WritePin(lcd_handle->reset_port, lcd_handle->reset_pin, GPIO_PIN_SET);
}





/*
 * @brief Resets the LCD screen - (setting pin to "LOW") activates the initialization sequence
 * where all of the registers are reset to their default setting
 *
 * @note It is recommended that the pin is set to "LOW" for at least 5us, and then set to "HIGH"
 * for at least 5uS for stable operation, which is why there are 100mS delays after both
 * "HAL_GPIO_WritePin" functions
 * @note While the pin is "LOW" no write functions will be accepted
 *
 * @retval None
 */
void NHD_LCD_Reset_Screen(NHD_LCD_Handle_t* lcd_handle)
{
  LCD_Reset_LOW(lcd_handle);
	HAL_Delay(100);
	LCD_Reset_HIGH(lcd_handle);
	HAL_Delay(100);
}



/*
 * @brief initialize the necessary LCD registers to values that will allow the module to function as required
 *
 * @note 1: Set screen to display characters from left to right
 * @note 2: Turn off all of the pixels before setting biases, power sources and voltage levels to avoid flickering
 * @note 3: Set screen to display characters from top to bottom
 * @note 4: Screen is multiplex display (multiple COMMON and SEGMENT Electrodes), since the number of COMS = 33, the
 * bias ratio of voltage levels required to drive the screen is set to 1/6
 * @note 5: Set module to use internal power circuits (booster, regulator and follower) to generate voltage levels
 * needed to drive the LCD
 * @note 6: Set the internal regulation ratio (non-inverting amp gain constant) for the regulator circuit to 3.5
 * @note 7: Set module in electronic volume (EV) adjust mode, then set alpha to 31 which in turn sets EV, the input
 * voltage of the regulator circuit to 1.698
 * @note 8: Now that all the settings have been given the proper values, turn the display on
 *
 *
 * @retval NHD_LCD status
 */

NHD_LCDstatus_t NHD_LCD_Init_Screen(NHD_LCD_Handle_t* lcd_handle)
{
	NHD_LCDstatus_t err_code = NHD_SPI_OK;
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_COLSD_LF)) != NHD_SPI_OK) //Set SEG (column) direction - left to right
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, TURN_OFF)) != NHD_SPI_OK) //Turn the display off
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_ROWD_TP)) != NHD_SPI_OK) //Set COM (row) direction - top to bottom
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_LCD_BIAS)) != NHD_SPI_OK) //Set LCD bias
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_PWR_CTRL)) != NHD_SPI_OK) //Power Control Set - Boost, Regulator and Follower are all on
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_RES_RTO)) != NHD_SPI_OK) //Set Resistor Ratio - 0x001 -> 3.5
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_EVM_CMD)) != NHD_SPI_OK) //Electronic Volume Command (set contrast) Double Byte: 1 of 2
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_EVM_VAL)) != NHD_SPI_OK) //Electronic Volume value (contrast value) Double Byte: 2 of 2
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, TURN_ON)) != NHD_SPI_OK) //Display ON
	{
		return err_code;
	}

	return err_code; //NHD_SPI_OK
}


/*
 * @brief Clear the screen by erasing display data
 *
 * @note The display is still on, but the all the data in the Display Data RAM which stores
 * the 'dot' data of the LCD is set to 0x00
 *
 * @retval NHD_LCD status
 */

NHD_LCDstatus_t clear_screen(NHD_LCD_Handle_t* lcd_handle)
{
	NHD_LCDstatus_t err_code = NHD_SPI_OK;
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, TURN_OFF)) != NHD_SPI_OK)
	{
		return err_code;
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_SRT_ROW)) != NHD_SPI_OK)
	{
		return err_code;
	}

	uint8_t page = SET_PG_ADDR;
	for (uint8_t i = 0; i < NUM_CHAR_ROWS; i++)
	{
		if ((err_code = NHD_LCD_Write_Command(lcd_handle, page)) != NHD_SPI_OK)	// send page address
		{
			return err_code;
		}
		//	Following two lines set the column address to leftmost column
		if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_COL_ADRU)) != NHD_SPI_OK)
		{
			return err_code;
		}
		if ((err_code = NHD_LCD_Write_Command(lcd_handle, SET_COL_ADRL)) != NHD_SPI_OK)
		{
			return err_code;
		}

		for (uint8_t j = 0; j < NUM_COLS; j++)
		{
			if ((err_code = NHD_LCD_Write_Data(lcd_handle, CLR_PGE_BYTE)) != NHD_SPI_OK)
			{
				return err_code;
			}
		}
		page++;//After 128 columns, go to the next page
	}
	if ((err_code = NHD_LCD_Write_Command(lcd_handle, TURN_ON)) != NHD_SPI_OK)//Turn the display back on
	{
		return err_code;
	}

	return err_code;
}

/*
 * @brief Command the the display module to perform an instruction
 *
 * @note Instructions include turning the display on/off, setting x and y axis print direction
 * bias levels for the multiplex display etc.
 * @note All commands are 1 byte, the data associated with the command is embedded in the byte
 * expect for the 'Set EV' command, which requires 2 bytes, one for the command and value each
 *
 * @param c: instruction for LCD module
 *
 * @retval NHD_LCD status
 */
NHD_LCDstatus_t NHD_LCD_Write_Command(NHD_LCD_Handle_t* lcd_handle, uint8_t c)
{
	HAL_StatusTypeDef err_code;

	LCD_Select(lcd_handle);
	LCD_OP_Command(lcd_handle);	//Set message type to command

	err_code = HAL_SPI_Transmit(&SPI_HANDLE, &c, 1, 100); 		// transmit command

	LCD_DeSelect(lcd_handle);	//De-select LCD Screen

	if (err_code != HAL_OK) //transmit data
	{
		switch (err_code)
		{
		case HAL_BUSY:
			return NHD_SPI_BUSY;
		case HAL_ERROR:
			return NHD_SPI_PARAM_ERROR;
		case HAL_TIMEOUT:
			return NHD_SPI_TIMEOUT;
		default:
			return NHD_SPI_PARAM_ERROR;
		}
	}
	return NHD_SPI_OK;

}

/*
 * @brief Send character data that is to be placed in the DDRAM and displayed on the
 * display to the module
 *
 * @param c: One fifth of character data to be sent to DDRAM of LCD module
 *
 * @retval NHD_LCD status
 */
NHD_LCDstatus_t NHD_LCD_Write_Data(NHD_LCD_Handle_t* lcd_handle, uint8_t d)
{
	HAL_StatusTypeDef err_code;

	LCD_Select(lcd_handle);;	//Select LCD Screen
	LCD_OP_Data(lcd_handle);		//Set message type to data

	err_code = HAL_SPI_Transmit(&SPI_HANDLE, &d, 1, 100); 		// transmit data

	LCD_DeSelect(lcd_handle);	//De-select LCD Screen

	if (err_code != HAL_OK) //transmit data
	{
		switch (err_code)
		{
		case HAL_BUSY:
			return NHD_SPI_BUSY;
		case HAL_ERROR:
			return NHD_SPI_PARAM_ERROR;
		case HAL_TIMEOUT:
			return NHD_SPI_TIMEOUT;
		default:
			return NHD_SPI_PARAM_ERROR;
		}
	}
	return NHD_SPI_OK;
}

/*
 * @brief Delete previous character data in the same 'row_index'text' that wasn't
 * overwritten by the current 'text' array
 *
 * @note if last 'text' string is shorter than current 'text' string, the characters
 * with indexes greater than the length of current string and less than or equal to the
 * length of the previous string will still exist in the DDRAM and will be displayed on
 * the screen, so this function erases those characters in the DDRAM
 *
 * @param text: text character array that was currently displayed on a page in the LCD module
 * @param row_index: page that the text is displayed on; 0, 1, 2, 3 from top to bottom
 *
 * @retval NHD_LCD status
 */
NHD_LCDstatus_t erase_trails(const char * text, uint8_t row_index)
{
  NHD_LCDstatus_t err_code = NHD_SPI_OK;
  if ((err_code = cmd_write(SET_PG_ADDR + row_index)) != NHD_SPI_OK) // send page address
  {
    return err_code;
  }

  //Get length of the current text
  size_t len = strlen(text);
  if (last_len[row_index] > len) // There are characters in that were not overwritten and need to be cleared
  {
    uint8_t trails = last_len[row_index] - len;

    for (uint8_t i = 0; i < trails; i++)
    {
      for (uint8_t j = 0; j < NUM_BYTES_PER_CHAR; j++)
      {
        if ((err_code = data_write(CLR_PGE_BYTE)) != NHD_SPI_OK)
        {
          return err_code;
        }
      }
    }
  }
  last_len[row_index] = len;

  return err_code;
}

/*
 * @brief Send string of characters to a print on a single page (character row)
 * on the LCD Screen
 *
 * @note There are 32 pixel rows on the LCD that the user can print on, these rows
 * are divided into 4 pages which have a height of 8 pixels.  Therefore, each character
 * will have a height of 8 pixels and a width of 5 pixel-columns
 * @note The character rows (pages) are numbered from 0 to 3, starting from the top
 *
 * @param text: character array to be printed on a page in the LCD module
 * @param row_index: page to print text on; 0, 1, 2, 3 from top to bottom
 *
 * @retval NHD_LCD status
 */
NHD_LCDstatus_t print_data(const char * text, uint8_t row_index)
{
	NHD_LCDstatus_t err_code = NHD_SPI_OK;

	if ((err_code = cmd_write(SET_PG_ADDR + row_index)) != NHD_SPI_OK) // send page address
	{
		return err_code;
	}
	//	Following two lines set the column address to leftmost column
	if ((err_code = cmd_write(SET_COL_ADRU)) != NHD_SPI_OK)
	{
		return err_code;
	}
	if ((err_code = cmd_write(SET_COL_ADRL)) != NHD_SPI_OK)
	{
		return err_code;
	}

	for (uint8_t i = 0; text[i] != '\0'; i++)
	{
		uint8_t c = (uint8_t)text[i] - 32;
		uint8_t val = 0;

		for (uint8_t j = 0; j < NUM_BYTES_PER_CHAR; j++)
		{
			val = Ascii_1[c][j];
			if ((err_code = data_write(val)) != NHD_SPI_OK)
			{
				return err_code;
			}
		}
	}

	if ((err_code = erase_trails(text, row_index)) != NHD_SPI_OK)
	{
		return err_code;
	}

	return err_code;
}

